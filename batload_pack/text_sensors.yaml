text_sensor:
  
  - platform: template
    name: Current_time
    lambda: |-
      auto time_text = id(sntp_time).now().strftime("%d.%m.%Y %H:%M:%S");
      return { time_text };
    update_interval: 60s
  
#  - platform: template
#    name: "${PROTECT}"
#    update_interval: 0.1s
#    lambda: |-
#      if (id(protectsensor).state == 0) {
#        return {"${normal}"};  
#      } else if (id(protectsensor).state == 1) {
#        return {"${OVP}"};
#      } else if (id(protectsensor).state == 2) {
#        return {"${OCP}"};
#      } else if (id(protectsensor).state == 3) {
#        return {"${OPP}"};
#      } else if (id(protectsensor).state == 4) {
#        return {"${LVP}"};
#      } else if (id(protectsensor).state == 5) {
#        return {"${OAH}"};  
#      } else if (id(protectsensor).state == 6) {
#        return {"${OHP}"};
#      } else if (id(protectsensor).state == 7) {
#        return {"${OTP}"};
#      } else if (id(protectsensor).state == 8) {
#        return {"${OEP}"};
#      } else if (id(protectsensor).state == 9) {
#        return {"${OWH}"};
#      } else if (id(protectsensor).state == 10) {
#        return {"${ICP}"};
#      } else {
#        return {"Error"};
#      }

#  - platform: template
#    name: CV CC old
#    update_interval: 0.1s
#    lambda: |-
#      if (id(cvccsensor).state == 0) {
#        return {"CV"};  
#      } else if (id(cvccsensor).state == 1) {
#        return {"CC"};
#      } else { 
#        return {"Error"};
#      }      
        
  #- platform: template
  #  name: Power Switch On Off old
  #  update_interval: 0.1s
  #  lambda: |-
  #    if (id(poweronoff).state == 0) {
  #      return {"OFF"};  
  #    } else if (id(poweronoff).state == 1) {
  #      return {"ON"};
  #    } else { 
  #      return {"Error"};
  #    }      

  #- platform: template
  #  name: "${LOCK}"
  #  update_interval: 0.1s
  #  lambda: |-
  #    if (id(keylock).state == 0) {
  #      return {"${unlock}"};  
  #    } else if (id(keylock).state == 1) {
  #      return {"${locked}"};
  #    } else { 
  #      return {"Error"};
  #    }      

  
  - platform: modbus_controller
    modbus_controller_id: sdm
    bitmask: 0
    register_type: holding
    address: 0x0F
    raw_encode: HEXBYTES
    name: " TEST Key Lock"
    lambda: |-#      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0000: return std::string("unlock");
        case 0001: return std::string("lock");
        default: return std::string("Unknown");
      }
      return x;

  - platform: modbus_controller
    modbus_controller_id: sdm
    bitmask: 0
    register_type: holding
    address: 0x11
    raw_encode: HEXBYTES
    name: "CC CV"
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("CV");
        case 1: return std::string("CC");
        default: return std::string("Unknown");
      }
      return x;

  - platform: modbus_controller
    modbus_controller_id: sdm
    bitmask: 0
    register_type: holding
    address: 0x12
    raw_encode: HEXBYTES
    name: "Power Switch On Off"
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0000: return std::string("off");
        case 0001: return std::string("on");
        default: return std::string("Unknown");
      }
      return x;

 
